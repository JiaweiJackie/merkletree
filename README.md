# merkletree

个人完成。

# 代码原理

默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。

![image](https://user-images.githubusercontent.com/105580300/181909137-3ed13850-bf21-4710-b197-5deefa7ba507.png)

默克尔树的特点：

1.首先是它的树的结构，默克尔树常见的结构是二叉树，但它也可以是多叉树，它具有树结构的全部特点。

2.默克尔树的基础数据不是固定的，想存什么数据由你说了算，因为它只要数据经过哈希运算得到的hash值。

3.默克尔树是从下往上逐层计算的，就是说每个中间节点是根据相邻的两个叶子节点组合计算得出的，而根节点是根据两个中间节点组合计算得出的，所以叶子节点是基础。

交付验证（SPV）通过默克尔树这一数据结构来完成，过程如下：

假设我们要验证区块中存在Hash值为9Dog:64（绿色框）的交易，我们仅需要知道1FXq:18、ec20、8f74（黄色框）即可计算出781a、5c71与Root节点（藕粉色框）的哈希，如果最终计算得到的Root节点哈希与区块头中记录的哈希（6c0a）一致，即代表该交易在区块中存在。这是因为我上文提到的两个点，一个是默克尔树是从下往上逐层计算的，所以只要知道相邻的另一个节点的hash值就可以一直往上计算直到根节点，另一个是根节点的hash值可以准确的作为一组交易的唯一摘要，依据这两点就可以来验证一笔交易是否存在。

![image](https://user-images.githubusercontent.com/105580300/181909200-728d9325-c52d-4645-b029-8f51160b21e9.png)

# 函数解释

create函数用来生成一棵新的默克尔树：

![image](https://user-images.githubusercontent.com/105580300/181909699-0f28a9c4-04c5-45e0-bb34-3596138f6807.png)


verify函数用来检验节点是否在默克尔树中，如果是则打印信息“in this merkle tree”：

![image](https://user-images.githubusercontent.com/105580300/181909660-1734b695-3bae-4477-be81-73fc6c4db6d5.png)

# 运行过程
![image](https://user-images.githubusercontent.com/105580300/181909645-e1d28a0d-0fd6-4ef5-be49-978d91dbfce2.png)
